<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: point-cloud-helper.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: point-cloud-helper.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* global THREE */
/* exported PointCloudHelper */

class PointCloudHelper {
   /**
    * @public
    * @param {HTMLImageElement} depthMapImage
    * @param {HTMLCanvasElement} renderCanvas
    * @param {number} depthFactor
    * @param {HTMLImageElement} textureImage
    * @returns {Promise&lt;number[]>}
    */
   static async calculatePointCloud(
      depthMapImage,
      renderCanvas,
      depthFactor = 0.15,
      textureImage = depthMapImage
   ) {
      const pointCloudHelper = new PointCloudHelper(renderCanvas);

      return new Promise((resolve) => {
         setTimeout(async () => {
            if (depthMapImage.naturalWidth === 0) return;

            if (pointCloudHelper.isRenderObsolete()) return;
            await pointCloudHelper.renderingContext.initialize();
            if (pointCloudHelper.isRenderObsolete()) return;

            const dataCanvas = document.createElement("canvas");
            dataCanvas.width = depthMapImage.naturalWidth;
            dataCanvas.height = depthMapImage.naturalHeight;
            const dataContext = dataCanvas.getContext("2d");

            dataContext.drawImage(depthMapImage, 0, 0);

            if (pointCloudHelper.isRenderObsolete()) return;

            const imageData = dataContext.getImageData(
               0,
               0,
               dataCanvas.width,
               dataCanvas.height
            ).data;

            dataContext.drawImage(textureImage, 0, 0);

            if (pointCloudHelper.isRenderObsolete()) return;

            const textureData = dataContext.getImageData(
               0,
               0,
               dataCanvas.width,
               dataCanvas.height
            ).data;

            const vertices = [];
            const vertexColors = [];

            const maxDimension = Math.max(dataCanvas.width, dataCanvas.height);
            /*
            const aspectWidth = dataCanvas.width / dataCanvas.height;
            const aspectHeight = dataCanvas.height / dataCanvas.width;
            */

            for (let x = 0; x &lt; dataCanvas.width; x++) {
               for (let y = 0; y &lt; dataCanvas.height; y++) {
                  const index = (y * dataCanvas.width + x) * 4;

                  const r = textureData[index + 0];
                  const g = textureData[index + 1];
                  const b = textureData[index + 2];

                  if (r !== 0 || g !== 0 || b !== 0) {
                     const xC = (x / maxDimension - 0.5) * 100;
                     const yC = (1 - y / maxDimension - 0.75) * 100;
                     const zC = (imageData[index] / 255) * 100 * depthFactor;

                     vertices.push(xC, yC, zC);
                     vertexColors.push(r / 255, g / 255, b / 255);
                  }
               }
               if (pointCloudHelper.isRenderObsolete()) return;
            }

            PointCloudHelper.vertices = vertices;
            resolve(vertices);

            pointCloudHelper.renderingContext.geometry.setAttribute(
               "position",
               new THREE.Float32BufferAttribute(vertices, 3)
            );
            pointCloudHelper.renderingContext.geometry.setAttribute(
               "color",
               new THREE.Float32BufferAttribute(vertexColors, 3)
            );

            if (pointCloudHelper.isRenderObsolete()) return;

            pointCloudHelper.renderingContext.geometry.attributes.position.needsUpdate = true;
            pointCloudHelper.renderingContext.geometry.attributes.color.needsUpdate = true;

            pointCloudHelper.renderingContext.render();

            pointCloudHelper.renderingContext.handleResize();
         }, 100);
      });
   }

   static async downloadOBJ() {
      const vertices = PointCloudHelper.vertices;

      if (vertices.length > 3) {
         await new Promise((resolve) => {
            setTimeout(() => {
               const filename = "point_cloud.obj";
               let objString = "";

               for (
                  let i = 0, vertexCount = vertices.length;
                  i &lt; vertexCount;
                  i += 3
               ) {
                  const x = vertices[i];
                  const y = vertices[i + 1];
                  const z = vertices[i + 2];
                  objString += "v " + x + " " + y + " " + z + "\n";
               }

               let element = document.createElement("a");
               element.style.display = "none";

               let blob = new Blob([objString], {
                  type: "text/plain; charset = utf-8",
               });

               let url = window.URL.createObjectURL(blob);
               element.setAttribute("href", window.URL.createObjectURL(blob));
               element.setAttribute("download", filename);

               document.body.appendChild(element);

               element.click();

               window.URL.revokeObjectURL(url);
               element.remove();

               resolve();
            });
         });
      }
   }

   /**
    * @public
    */
   static cancelRenderJobs() {
      PointCloudHelper.renderId++;
   }

   /**
    * @public
    * @param {HTMLCanvasElement} canvas
    */
   static clearCanvas(canvas) {
      const pointCloudHelperRenderingContext =
         PointCloudHelperRenderingContext.getInstance(canvas);

      pointCloudHelperRenderingContext.geometry.setAttribute(
         "position",
         new THREE.Float32BufferAttribute([], 3)
      );
      pointCloudHelperRenderingContext.geometry.setAttribute(
         "color",
         new THREE.Float32BufferAttribute([], 3)
      );

      pointCloudHelperRenderingContext.geometry.attributes.position.needsUpdate = true;
      pointCloudHelperRenderingContext.geometry.attributes.color.needsUpdate = true;

      pointCloudHelperRenderingContext.render();
   }

   /**
    * @private
    * @param {HTMLCanvasElement} renderCanvas
    */
   constructor(renderCanvas) {
      this.renderId = PointCloudHelper.renderId;

      this.renderingContext =
         PointCloudHelperRenderingContext.getInstance(renderCanvas);
   }

   /**
    * @private
    * @returns {boolean}
    */
   isRenderObsolete() {
      return this.renderId &lt; PointCloudHelper.renderId;
   }
}
PointCloudHelper.renderId = 0;

/** @type {PointCloudHelperRenderingContext[]} */
const PointCloudHelperRenderingContext_instances = [];

class PointCloudHelperRenderingContext {
   /**
    * @public
    * @param {HTMLCanvasElement} renderCanvas
    * @returns {PointCloudHelperRenderingContext}
    */
   static getInstance(renderCanvas) {
      for (
         let i = 0;
         i &lt; PointCloudHelperRenderingContext_instances.length;
         i++
      ) {
         const testInstance = PointCloudHelperRenderingContext_instances[i];
         if (testInstance.renderCanvas === renderCanvas) {
            const instance = testInstance;
            return instance;
         }
      }

      const instance = new PointCloudHelperRenderingContext(renderCanvas);
      return instance;
   }

   /**
    * @private
    * @param {HTMLCanvasElement} renderCanvas
    */
   constructor(renderCanvas) {
      this.initialized = false;
      this.renderCanvas = renderCanvas;

      this.renderer = new THREE.WebGLRenderer({
         canvas: renderCanvas,
         alpha: true,
         antialias: true,
      });
      this.camera = new THREE.PerspectiveCamera(
         50,
         renderCanvas.width / renderCanvas.height,
         0.01,
         1000
      );

      // @ts-ignore
      this.controls = new THREE.OrbitControls(this.camera, this.renderCanvas);
      this.scene = new THREE.Scene();
      this.geometry = new THREE.BufferGeometry();
      this.material = new THREE.PointsMaterial({
         size: 2,
         vertexColors: true,
      });
      this.pointCloud = new THREE.Points(this.geometry, this.material);

      this.pointCloud.rotateX(35 * (Math.PI / 180));
      this.pointCloud.translateY(15);

      PointCloudHelperRenderingContext_instances.push(this);

      if (
         PointCloudHelperRenderingContext_instances.length >
         PointCloudHelperRenderingContext.MAX_INSTANCES
      ) {
         console.warn(
            "PointCloudHelperRenderingContext exceeded maximum render canvas instance count. The last instance gets deleted."
         );
         PointCloudHelperRenderingContext_instances.shift();
      }
   }

   async render() {
      await this.initialize();
      this.renderer.render(this.scene, this.camera);
   }

   /**
    * @public
    */
   async initialize() {
      if (this.initialized) {
         return;
      }
      await new Promise((resolve) => {
         setTimeout(() => {
            this.scene.add(this.pointCloud);

            this.camera.position.z = 75;
            this.camera.position.y = -100;

            this.controls.target = new THREE.Vector3(0, 0, 0);

            this.initialized = true;
            resolve();

            this.controls.addEventListener("change", () => {
               this.render();
            });
            window.addEventListener("resize", this.handleResize.bind(this));

            this.controls.update();
            this.handleResize();
         });
      });
   }

   /**
    * @public
    */
   handleResize() {
      const width = this.renderCanvas.clientWidth;
      const height = this.renderCanvas.clientHeight;
      const needResize =
         this.renderCanvas.width !== width ||
         this.renderCanvas.height !== height;
      if (needResize) {
         this.renderer.setSize(width, height);

         this.camera.aspect =
            this.renderCanvas.width / this.renderCanvas.height;
         this.camera.updateProjectionMatrix();
         this.render();
      }
   }
}

/** @type {number[]} */
PointCloudHelper.vertices = [];

/** @constant */
PointCloudHelperRenderingContext.MAX_INSTANCES = 8;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="GlslContext.html">GlslContext</a></li><li><a href="GlslFloat.html">GlslFloat</a></li><li><a href="GlslInteger.html">GlslInteger</a></li><li><a href="GlslMatrix.html">GlslMatrix</a></li><li><a href="GlslMatrix3.html">GlslMatrix3</a></li><li><a href="GlslOperation.html">GlslOperation</a></li><li><a href="GlslRendering.html">GlslRendering</a></li><li><a href="GlslShader.html">GlslShader</a></li><li><a href="GlslVariable.html">GlslVariable</a></li><li><a href="GlslVector.html">GlslVector</a></li><li><a href="GlslVector2.html">GlslVector2</a></li><li><a href="GlslVector3.html">GlslVector3</a></li><li><a href="GlslVector4.html">GlslVector4</a></li><li><a href="Shader.html">Shader</a></li><li><a href="VirtualInputRenderer.html">VirtualInputRenderer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#calculateDepthMap">calculateDepthMap</a></li><li><a href="global.html#calculateEverything">calculateEverything</a></li><li><a href="global.html#calculateNormalMap">calculateNormalMap</a></li><li><a href="global.html#calculatePointCloud">calculatePointCloud</a></li><li><a href="global.html#cancelAllRenderJobs">cancelAllRenderJobs</a></li><li><a href="global.html#getGlslVarType">getGlslVarType</a></li><li><a href="global.html#inputOrCalculationTypeChange">inputOrCalculationTypeChange</a></li><li><a href="global.html#inverse">inverse</a></li><li><a href="global.html#loadInputImages">loadInputImages</a></li><li><a href="global.html#LUMINANCE_CHANNEL_QUANTIFIER">LUMINANCE_CHANNEL_QUANTIFIER</a></li><li><a href="global.html#PointCloudHelperRenderingContext_instances">PointCloudHelperRenderingContext_instances</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Wed Sep 15 2021 19:03:01 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
